
\documentclass[a4paper, oneside, 11pt]{report}
\usepackage{epsfig,pifont,float,multirow,amsmath,amssymb}
\newcommand{\mc}{\multicolumn{1}{c|}}
\newcommand{\mb}{\mathbf}
\newcommand{\mi}{\mathit}
\newcommand{\oa}{\overrightarrow}
\newcommand{\bs}{\boldsymbol}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\usepackage{algorithm}
\usepackage{algorithmic}
\topmargin = 0pt
\voffset = -80pt
\oddsidemargin = 15pt
\textwidth = 425pt
\textheight = 750pt

\begin{document}

\begin{titlepage}
\begin{center}
\rule{12cm}{1mm} \\
\vspace{1cm}
{\large  CMP-6048A Advanced Programming}
\vspace{7.5cm}
\\{\Large Project Report - 15 December 2021}
\vspace{1.5cm}
\\{\LARGE Maths Interpreter Software}
\vspace{1.0cm}
\\{\Large Group members: \\ James Mason and Nia Preston}
\vspace{10.0cm}
\\{\large School of Computing Sciences, University of East Anglia}
\\ \rule{12cm}{0.5mm}
\\ \hspace{8.5cm} {\large Version 1.0}
\end{center}
\end{titlepage}


\setcounter{page}{1}
%\pagenumbering{roman}
%\newpage


\begin{abstract}
In this project, our aim was to create a maths-based interpreter, capable of a range of useful mathematical operations outlined by the project breif.
This inludes expression evaluation and funtion graphing via abstract syntax tree based interpretation. The asbtract syntax tree allows the correct precedence when interpreting based on the depth of the node in the tree. Each node within the tree, implements a visitor pattern allowing further abstraction and generalisation within the interpreter. We used a scrum based devleopment methodology to develop our langugae in sprints, allowing us to evelove our programn over time with frequenct re-adjustment of requirements and functionality.


and what your final results are, your final outcome or deliverable and conclusion.
\end{abstract}

\chapter{Introduction}
\label{chap:intro}


\section{Project statement}
The purpose of this project is to create a piece of software that is an interpreter for mathematical functions. It will run both as an interactive prompt and a utility to interpret and execute pre-written files.
It will additionally provide the ability to visualise mathematical functions such as on a graph.

\section{MoSCoW}
The foillowing outlines the requirements we aim to meet with this software.

\subsection{Musts}

\begin{itemize}
	\item Expressions for basic arithmetic
	\item Print Statements
	\item Commands
	\item Custom syntax using a custom lexer and parser
\end{itemize}

\subsection{Shoulds}

\begin{itemize}
	\item Expressions for variable assignment and exponentiation
	\item Conditional Statements
	\item Function Declaration
	\item Mathmatical function visualisation
	\item Flexible and scalable architecture
	\item Simple trigonometric functions
	\item Zero-crossings finder
\end{itemize}

\subsection{Coulds}
\begin{itemize}
	\item Intuitive GUI
	\item Interactive visualisations
	\item Differentiation and integration of functions
	\item Simple equation solver (for example finding a variable)
\end{itemize}

\subsection{Won'ts}
\begin{itemize}
	\item Imaginary numbers
	\item 3D function graphing
	\item Multi-variable equation solver (beyond simple simultaneous equations)
\end{itemize}

\section{Report structure}

\subsection {Background}

The background section of this report will comprise of an analysis of similar systems. This will allow us a better understanding of the functionalities our system should contain as well as negative points our system should avoid.

\subsection {Methodology}

This section outlines the design patterns and data structures we used in our software.

\subsection {Implementation}

Our implementation describes the structure we used to develop our system and the requirments we met in each sprint. It also details how we adapted our requirements overtime.

\subsection {Testing}

The testing section is a record of how we ensured each requirement was met and the functionality performed as expected.

\subsection {Conclusion}

This chapter deatils the success and faliure of our system and what we have achieved during this process.

\chapter{Background}

To better understand what we do and don't want from our software, we analysed systems on the market that have a similar function to our own. We analysed the good and bad features of each and identfied any we would take forward into our own product.

\section{Similar Systems}

\subsection{MATLAB\cite{MATLAB}}

MATLAB is a standalone piece of mathematical software designed with a focus on manipulation of mathematical data types such as matrices as well as including generic programming. 
It is a turing complete language, so it is has a very wide range of possible uses, but it is very much geared towards easily running numeric calculations. It has its own syntax,
which means that users will have to learn it, but the custom syntax it uses is very similar to many popular programming languages, and so users with that background may find transitioning easier.
From this program, we like the layout of the user interface. It is intuitive and everything you ened is in easy reach. This is the sort of UI we would liek to implement in our own product.
However, this program takes up alot of storage and does not run well on lower specification machines. We would like our own product to be able to run on most desktop devices so it is more accessible.

\subsection{Math Inspector\cite{Math_Inspector}}

Math Inspector is a package of addons for Python which allow for mathematical functions to be graphically visualised, both by displaying a flow-type diagram of the function as well as graphing the numeric outputs across a range.
 Since it is an addon for Python, people who are familiar with the language already shouldn't have much difficulty using it. It may, however, mean that people have to install more than what they need in order to get it to run.
Whilst the python basis may make it easier for some people, many who wish to use this program will have no prior python knowledge. For this reason, we feel the benefits of a familiar language are outweighed bythe cost of having to install the extra programs. Therefore, we will not be doing something similar in own own system.

\subsection{Wolfram Mathematica\cite{Mathematica}}

Wolfram Mathematica is an interactive tool used to define and visualise mathmatical functions. It's main foucs is using technology to visualise mathmatics and to allow the user to directly implement a vast variety of features. It offers over 5000 different in-built maths functions, meaning it contains very few restrictions. It runs on it's own in-built language which may take the user some time to learn and become familiar with. Its' main strength is definately its advanced visulisation features.
The vast variety of tools it offers in nice but will be a waste for most people. For our system, we will focus on the most common maths functions to maximise use whilst minimising memory cost. In the future, our system could use addons to cover more areas of mathematics without the user having to install hundreds of tools they will never need.


\subsection{Maple\cite{Maple}}

Maple offers a number of different versions of its' software allowing the user to tailor their experience before they even download. It's main goal is solving equpations but it still offers an intuetive UI with function visulisation features. It allows the user to explore a range of mathmatical fields by offering a large variety of in-built functions. Similarly to the previous system, it operates using it's own programming language which may take users time to learn and understand. The different versions of the software (tailored based on who is using it) is this systems' main strength.
Our system should also include an intuative user interface. The different systems versions are a definate positive and something we would take forward in furture versions of our product. For now, our product will focus on the most commonly used areas of mathmeatics to maximise usability.


\chapter{Methodology}

Throughout this project, we used a number of different method to implement the variuous features of our software. Theses methods and outline below.



\section{Method 1: Abstract Syntax Tree}

Each operator and operand has its own unique that extends from Expression and each
statement has its own class that extends from the Statement class. Each node withing
each of those classes contains information about how that feature functions and stores it’s
own requisit data.

\subsection{Visitor Design Pattern}

This design pattern implements an interface which allows code to be run differently based
on the type of the nodew within the tree.

\section{Method 2: Recursive Decent}

This algorithms is a type of tope down parsing that functions by recursively calling functions that represent the non-terminal symbols in the grammar

\section{Method 3: Post-Order Traversal}

This algorithm is used to traverse the abstract syntax tree. Used to evaluate expressions
within the interpreter. It makes use of the visitor patterns as it calls this pattern at each
node to understand how to handle each node. It traverses in a depth-first manner.



\chapter{Implementation}\label{Impl}

We are implementing the agile development methodology for this project with a SCRUM inspired approach, using short 1-2 week sprints and adjusting the devleopment trajectory at the end of each.

\subsection{Sprint 1}

For our first sprint, we defined the following set of requirements: 

\begin{enumerate}
\item Create the program skeleton we can build upon 
\item Build the Lexer and parser for our language 
\item Allow the program to identify integers 
\item Allow the program to recognize basic operators, including addition, multiplication, subtraction, division and brackets 
\item The program should be able to execute the basic operation is can identify 
\end{enumerate}

\subsubsection{Requirement 1: }

The program now contains the different classes it will need to run. These include the Lexer Class which is the class used to identify the different tokens, The parser class that checks the syntax of the languages and the execution class that runs through the stack and performs the operations held there in the correct order. There is also the main class that is responsible for the input display and parsing that input to the Lexer. 

\subsubsection{Requirement 2: }

Once all the classes were created, we were able to build the Lexer and parser for our language. The Lexer can correctly identify integers, plus signs, minus signs, multiplication and division signs and brackets as well as ignoring blank space. The only limitation of our current Lexer is that it is unable to handle integer outside of the integer limit imposed by Java. 

The parser can check the syntax of the language by making sure the tokens are written the correct order and lets the user know if there is an issue. 

\subsubsection{Requirement 3: }

When the Lexer encounters a digit character, a loop begins and checks each concurrent characters’ digit status. If the next character is a digit also, the loop continues. When the Lexer encounters a non-digit character, the loop ends and a number token is added to the token array and the string of digits is converted into a numerical representation which is put into the symbol table. The symbol table is implemented as a map. The index key for the numeric value is the index in the array of the corresponding number token. 

\subsubsection{Requirement 4: }

The recognition of basic operators works in the same manner as the integer recognition except without the need for a looping function. Each operator is assigned a given token which is added to the token array upon recognition. 

\subsubsection{Requirement 5: }

Each token from the token array is copied onto the operator stack and the integers corresponding to the number tokens are copied onto the number stack from the symbol table. When a complete expression has been transferred onto the stack, it will be evaluated and the result of that expression with replace the operands used on the number stack. Any operators used are removed from the stack. Token will then continue to be copied onto the two stacks until the end of the token array is reached.  

When the program encounters a right bracket, we know a left bracket must exist on the stack as the parser has validated the code. This means that when a right bracket is encountered, the program continually runs calculate until the left bracket reaches the top of the stack. This ensures the number at the top of the number stack is the evaluation of the expression within brackets, ensuring the order of operations is preserved. 

\subsection{Sprint 2}

For our second sprint, we defined the following set of requirements: 

\begin{enumerate}
\item Allow the program to recognise variable identifiers
\item Be able to assign value to a variable
\item The program should be able to evalute expression that contain pre-defined variables
\end{enumerate}

\subsubsection{Requirement 1: }

The lexer class cycles through the chracters typed by the user. If the character is not a number or a reserved symbol, the program identifies it as a variable. the concecutive characters are then checked and added to the variable name if they are alphanumeric. This process ends when a non-alphanumeric charcter is reached.
The symbol table has also been updated so it can hold variable names as well as numbers.
This requirement has been succefully met.

\subsubsection{Requirement 2: }

To begin developing the assignmnet functionality, we have used the equals sign to represent assignment for simplicity. This sign has be added as a reserved character to identify assignment operations. When an equals gin is preceded by a varible and proceeded by an integer, the interger value is mapped to the varible. If the assignment value is an expression, the expression is evaluated and the soltuion mapped to the variable.
This requirement has been successfully met.

\subsubsection{Requirement 3: }

When the program evaluates an expression that contains a varible, the execution class identifes the value mapped to the variable and replaces it in the expression. The xpression is then evalutated as normal and the solution displayed.
This requirement has been succefully met.

\subsection{Sprint 3}

For our second sprint, we defined the following set of requirements:

\begin{enumerate}
\item Developing the abstract syntax tree
\item Adding the graphing functionality
\item Allowing the support of floats
\end{enumerate}

We were able to fully implement and test these requirements quickly so we intergrated
a number of extra features into our program on top of our base requirements. These
included:
\begin{enumerate}
\item Support for negative numbers and unary operators
\item Support for simple statements including print, variable declaration and graph plotting
\item  Ability to calculate exponentials
\end{enumerate}

\subsubsection{Requirement 1: }

Each type of operator has it's own class. The depth of the tree determines the order in which the operations will be executed. The higher an operator exists within the tree, the lower their priority.

\subsubsection {Requirement 2: }

To add the graph, we used the Java2D library. Our programn take each point, as calculated by the interpreter, and maps them onto a simple axis in a window. Currently, this graph only supports positive axis and does not scale with the window size, this means only simple functions can be plotted.

\subsubsection {Requirement 3: }

To support floats, our program detecs any dots within a number. If a dot is preset, it continues to sacn through until the end of the number is reached. This value is then saved as a float rather than a double.

\subsubsection {Extra Requirement 1: }

We have another class within the abstyract syntax tree that supports unary operators, including negative numebrs.

\subsubsection {Extra Requirement 2: }

Statements also become part of the ast. The experessions they contain are the children of the statement within the tree.

\subsubsection { Extra Requirement 3: }

Exponentials are identified in the same way as other binary opperators. There is a new step in the parsing process required for it as it has a higher priority than most other opperators.


\subsection{Sprint 4}
Our fourth sprint involved the following set of requirements:
\begin{enumerate}
\item Adding support for negative numebrs on the graph
\item Allowing the graph to change size dynamically with the window size
\item Add support for boolean types and logic
\item Add support for control flow statements
\end{enumerate}

\subsubsection{Requirement 1: }
This additon was relatively simple. We change to code4 to draw to lines that crossed in the center to act as the axis, we also modified our mapping function to account for  the change in position of (0,0).
\subsubsection{Requirement 2: }
During our research for this requirement, we found that JPanel has built in getWidth() and getHeight() functions. This meant we could replace our hard-coded constants for these values in our calculations which meant anything drawn in the window would automatically scale as the window size was changed.
We also found out abou the Points2D library which is compatible with Java 2D, so we changed our code to handle points with this library rather than manually.
\subsubsection{Requirement 3: }
This is another literal type and the comparissons for them are binary operators that exist within the abstract syntax tree. We also have support for "and" and "or" which works similarly to other binary operators but with the ability to short circuit depending on the first operand.
\subsubsection{Requirement 4: }
Similary to other statements, these additions are new nodes in the syntax tree with the same precedence as other statements like print. If statments looks for an expression as the condition and a statement as the thing to do if the condition is true. While statements work similarly except for that they repeat the statement until the expression is no longer true.

\subsection{Sprint 5}
These were the frequirements we outlined for our final sprint:
\begin{enumerate}
\item Adding function syntax
\item Creating a degrees to radians function
\item Adding more user customisation of the graphing feature
\item Create a root finding algorithm to solve equations
\end{enumerate}


\chapter{Testing}

This section details the testing we performed at the end of each sprint to make sure we meet each of the requirements set out at the beginning of the sprint.

\subsection{Sprint 1}

\begin{tabular}{|p{8mm}|p{60mm}|p{30mm}|p{15mm}|}Test No. & Test Case & Test Data & Result \\ \hline
1 & The program is able to identify a number & 5 \newline 83 \newline 324876312487124  &  PASSED \newline PASSED \newline FAILED \\
2 & The program can idenify and evaluate an addition expression & 5+5 \newline 54+6 \newline 2+7  &  PASSED \newline PASSED \newline PASSED \\
3 & The program can idenify and evaluate a subtraction expression & 5-5 \newline 18-9 \newline 4-0  &  PASSED \newline PASSED \newline PASSED \\
4 & The program can idenify and evaluate a multiplication expression & 5*5 \newline 4*7 \newline 32*8  &  PASSED \newline PASSED \newline PASSED \\
5 & The program can idenify and evaluate a division expression & 5/5 \newline 42*7 \newline 100/10  &  PASSED \newline PASSED \newline PASSED \\
6 & The program can evalute expressions that include blank space & 5 + 5 \newline 10 - 8 \newline 32 - 23  &  PASSED \newline PASSED \newline PASSED \\
7 & The program can idenify and evaluate expression with multiple operators & 4+7-2\newline 23+6+4 \newline 1*8/4 &  PASSED \newline PASSED \newline PASSED \\
8 & The program can idenify and handle incorrect syntax & 5+ \newline 5+(5 \newline *8  &  PASSED \newline PASSED \newline PASSED \\
9 & The program can idenify and evaluate expression involving brackets & 5+(4-2+3) \newline (4*2)+7 \newline 10/5+(6*8)  &  PASSED \newline PASSED \newline PASSED \\
\end{tabular}

\subsection{Sprint 2}

\begin{tabular}{|p{8mm}|p{60mm}|p{30mm}|p{15mm}|}Test No. & Test Case & Test Data & Result \\ \hline
1 & The program can assign a value to a variable & x=5 \newline foo=56 \newline y=9  &  PASSED \newline PASSED \newline FAILED \\
2 & The program can assign an expression to a variable & a = 19+7 \newline y = 7-5 \newline bar = 3*6  &  PASSED \newline PASSED \newline PASSED \\
3 & The program can evaluate an expression that inclues a variable & x-10 \newline y = 7+x \newline foo*x  &  PASSED \newline PASSED \newline PASSED \\
4 & The program can idenifyincorrect assignment expression & 5x \newline x465 \newline foo x+6  &  FAILED \newline FAILED \newline FAILED \\
\end{tabular}

\chapter{Discussion, conclusion and future work}

Briefly discuss and conclude your achievements and put them in perspective with the MoSCoW analysis you did early on. Be honest by declaring for example `S' categorised objectives which did not make it to the final deliverable rather than reversely modifying your MoSCoW in Chapter \ref{chap:intro}! Also discuss future developments and how you see the deliverable improving if more time could be spent. Note that this section should not be used as a medium to vent frustrations on whatever did not work out (pandemic, group partners, etc.) as there are other means for this (labs, e-mail MO, ...) that should be used well before any such problems become an issue.


\bibliographystyle{unsrt}
\bibliography{References}

\chapter*{Contributions}

State here the \% contribution to the project of each individual member of the group and describe in brief what each member has done (if this corresponds to particular sections in the report then please specify these).

\chapter*{Appendix A}

Put in tables of data or protocols (e.g. for testing) or code listings or UML diagrams which may take up several pages and do not sit well in the main body text.

\end{document}

